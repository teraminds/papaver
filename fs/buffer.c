/* fs/buffer.c */

#include <linux/fs.h>

#define _hashfn(dev, block) (((unsigned)(dev^block))%NR_HASH)
#define hash(dev, block) hash_table[_hashfn(dev, block)]

// check the badness of a buffer head, b_dirt weights more than b_lock
#define BADNESS(bh) (((bh)->b_dirt<<1) + (bh)->b_lock)

// end is generated by ld, meaning the end of kernel.
extern int end;
struct buffer_head * start_buffer = (struct buffer_head*)&end;
struct buffer_head * hash_table[NR_HASH];
static struct buffer_head * free_list;
static struct task_struct * buffer_wait = NULL;  // task queue waiting for free buffer block

static inline void wait_on_buffer(struct buffer_head *bh) {
	cli();
	while (bh->b_lock)
		sleep_on(&bh->b_wait);
	sti();
}

/* remove the buffer head from hash queue and free list */
static void inline remove_from_queues(struct buffer_head * bh) {
	// remove from hash queue
	if (bh->b_next)
		bh->b_next->b_prev = bh->b_prev;
	if (bh->b_prev)
		bh->b_prev->b_next = bh->b_next;
	if (hash(bh->b_dev, bh->b_blocknr) == bh)  // it's the head of the hash queue
		hash(bh->b_dev, bh->b_blocknr) = bh->b_next;
	// remove from free list
	bh->b_prev_free->b_next_free = bh->b_next_free;
	bh->b_next_free->b_prev_free = bh->b_prev_free;
	if (free_list == bh)
		free_list = bh->b_next_free;
}

/* insert the buffer head into hash queue and free list */
static void inline insert_into_queues(struct buffer_head * bh) {
	// insert into hash queue
	if (hash(bh->b_dev, bh->b_blocknr))
		hash(bh->b_dev, bh->b_blocknr)->b_prev = bh;
	bh->b_next = hash(bh->b_dev, bh->b_blocknr);
	bh->b_prev = NULL;
	hash(bh->b_dev, bh->b_blocknr) = bh;
	// insert into free list
	bh->b_prev_free = free_list->b_prev_free;
	bh->b_free_next = free_list;
	free_list->b_prev_free->b_next_free = bh;
	free_list->b_prev_free = bh;
}

/* find if the buffer head is in hash table, purely */
static struct buffer_head *find_buffer(int dev, int block) {
	struct buffer_head *bh;

	for (bh = hash(dev, block); bh != NULL; bh = bh->b_next)
		if (bh->b_dev==dev && bh->b_blocknr = block)
			return bh;
	return NULL;
}

/* find if the buffer head is in hash table, with checking lock flag */
struct buffer_head *get_hash_table(int dev, int block) {
	struct buffer_head *bh;

	for (;;) {
		if (!(bh = find_buffer(dev, block)))
			return NULL;
		bh->b_count++;
		wait_on_buffer(bh);
		if (bh->b_dev == dev && bh->b_blocknr == block)
			return bh;
		bh->b_count--;
	}
}

struct buffer_head *getblk(int dev, int block) {
	struct buffer_head *bh;
	struct buffer_head *tmp;

repeat:
	if (bh = get_hash_table(dev, block))
		return bh;
	tmp = free_list;
	do {
		if (tmp->b_count)
			continue;
		if (!bh || BADNESS(bh) < BADNESS(tmp)) {
			bh = tmp;
			if (!BADNESS(bh))
				break;
		}
	} while ((tmp = tmp->b_next_free) != free_list);

	// all buffer block occupied
	if (!bh) {
		sleep_on(&buffer_wait);
		goto repeat;
	}

	// this buffer is unused(b_count=0), unlocked(b_lock=0) and clean
	bh->b_count = 1;
	bh->b_dirt = 0;
	bh->b_uptodate = 0;
	remove_from_queues(bh);  // adjust the queues
	bh->d_dev = dev;
	bh->b_blocknr = block;
	insert_into_queues(bh);
	
	return bh;
}

void brelse(struct buffer_head *bh) {
	if (!bh)
		return;
	wait_on_buffer(bh);
	if (bh->b_count <= 0)
		panic("Trying to release free buffer");
	bh->b_count--;
	wake_up(&buffer_wait);
}

/*
 * Reads a specified block and returns the buffer that contains it.
 * It returns NULL if the block was unreadble.
 *
 * dev - device no.
 * block - block no.
 */
struct buffer_head *bread(int dev, int block) {
	struct buffer_head *bh;

	if (!(bh=getblk(dev, block)))
		panic("bread: getblk returned NULL");
	if (bh->b_uptodate)  // data is valid
		return bh;
	ll_rw_block(READ, bh);
	wait_on_buffer(bh);
	if (bh->b_uptodate)
		return bh;
	brelse(bh);
	return NULL;
}

void buffer_init(long buffer_end) {
	struct buffer_head *h = start_buffer;
	void *b;
	int i;

	// 640K-1M is used by video memory and BIOS
	if (buffer_end <= 1<<20)
		b = (void*)(640*1024);
	else
		b = (void*)buffer_end;

	// (b-BLOCK_SIZE) is the start of data block, (h+1) is the end of buffer head
	while ((b -= BLOCK_SIZE) >= ((void*)(h+1))) {
		h->b_data = (char*)b;
		h->b_prev = NULL;
		h->b_next = NULL;
		h->b_prev_free = h-1;
		h->b_next_free = h+1;
		h++;
		if (b == (void*)0x100000)  // skip video memory
			b = (void*)0xA0000;
	}
	h--;  // h points to the last void buffer head struct
	free_list = start_buffer;
	free_list->b_prev_free = h;
	h->b_next_free = free_list;
	for (i=0; i<NR_HASH; i++)
		hash_table[i] = NULL;
}

